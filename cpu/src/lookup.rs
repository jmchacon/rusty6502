use crate::{AddressMode, Opcode, Operation};
use color_eyre::eyre::{eyre, Result};
use lazy_static::lazy_static;
use std::collections::{HashMap, HashSet};
use strum::IntoEnumIterator;

lazy_static! {
    // OPCODES is a hashmap of the Opcode -> Hashmap of valid addressing modes and their u8 opcode values.
    // This is a vector since NOP, HLT and a few others duplicate address mode and can do the same thing from N values.
    // An assembler should simply use the first value of each Vec unless they want to randomly chose.
    static ref OPCODES: HashMap<Opcode, HashMap<AddressMode, Vec<u8>>> = {
        let mut m = HashMap::new();

        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x8B];
        hm.insert(AddressMode::Immediate, v);
        let v: Vec<u8> = vec![0x6D];
        hm.insert(AddressMode::Absolute, v);
        let v: Vec<u8> = vec![0x7D];
        hm.insert(AddressMode::AbsoluteX, v);
        let v: Vec<u8> = vec![0x79];
        hm.insert(AddressMode::AbsoluteY, v);
        let v: Vec<u8> = vec![0x69];
        hm.insert(AddressMode::Immediate, v);
        let v: Vec<u8> = vec![0x61];
        hm.insert(AddressMode::IndirectX, v);
        let v: Vec<u8> = vec![0x71];
        hm.insert(AddressMode::IndirectY, v);
        let v: Vec<u8> = vec![0x65];
        hm.insert(AddressMode::ZeroPage, v);
        let v: Vec<u8> = vec![0x75];
        hm.insert(AddressMode::ZeroPageX, v);
        m.insert(Opcode::ADC, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x9F];
        hm.insert(AddressMode::AbsoluteY, v);
        let v: Vec<u8> = vec![0x93];
        hm.insert(AddressMode::IndirectY, v);
        m.insert(Opcode::AHX, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x4B];
        hm.insert(AddressMode::Immediate, v);
        m.insert(Opcode::ALR, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x0B, 0x2B];
        hm.insert(AddressMode::Immediate, v);
        m.insert(Opcode::ANC, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x2D];
        hm.insert(AddressMode::Absolute, v);
        let v: Vec<u8> = vec![0x3D];
        hm.insert(AddressMode::AbsoluteX, v);
        let v: Vec<u8> = vec![0x39];
        hm.insert(AddressMode::AbsoluteY, v);
        let v: Vec<u8> = vec![0x29];
        hm.insert(AddressMode::Immediate, v);
        let v: Vec<u8> = vec![0x21];
        hm.insert(AddressMode::IndirectX, v);
        let v: Vec<u8> = vec![0x31];
        hm.insert(AddressMode::IndirectY, v);
        let v: Vec<u8> = vec![0x25];
        hm.insert(AddressMode::ZeroPage, v);
        let v: Vec<u8> = vec![0x35];
        hm.insert(AddressMode::ZeroPageX, v);
        m.insert(Opcode::AND, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x6B];
        hm.insert(AddressMode::Immediate, v);
        m.insert(Opcode::ARR, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x0E];
        hm.insert(AddressMode::Absolute, v);
        let v: Vec<u8> = vec![0x1E];
        hm.insert(AddressMode::AbsoluteX, v);
        let v: Vec<u8> = vec![0x0A];
        hm.insert(AddressMode::Implied, v);
        let v: Vec<u8> = vec![0x06];
        hm.insert(AddressMode::ZeroPage, v);
        let v: Vec<u8> = vec![0x16];
        hm.insert(AddressMode::ZeroPageX, v);
        m.insert(Opcode::ASL, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0xCB];
        hm.insert(AddressMode::Immediate, v);
        m.insert(Opcode::AXS, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x90];
        hm.insert(AddressMode::Relative, v);
        m.insert(Opcode::BCC, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0xB0];
        hm.insert(AddressMode::Relative, v);
        m.insert(Opcode::BCS, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0xF0];
        hm.insert(AddressMode::Relative, v);
        m.insert(Opcode::BEQ, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x2C];
        hm.insert(AddressMode::Absolute, v);
        let v: Vec<u8> = vec![0x24];
        hm.insert(AddressMode::ZeroPage, v);
        m.insert(Opcode::BIT, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x30];
        hm.insert(AddressMode::Relative, v);
        m.insert(Opcode::BMI, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0xD0];
        hm.insert(AddressMode::Relative, v);
        m.insert(Opcode::BNE, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x10];
        hm.insert(AddressMode::Relative, v);
        m.insert(Opcode::BPL, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x00];
        hm.insert(AddressMode::Immediate, v);
        m.insert(Opcode::BRK, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x50];
        hm.insert(AddressMode::Relative, v);
        m.insert(Opcode::BVC, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x70];
        hm.insert(AddressMode::Relative, v);
        m.insert(Opcode::BVS, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x18];
        hm.insert(AddressMode::Implied, v);
        m.insert(Opcode::CLC, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0xD8];
        hm.insert(AddressMode::Implied, v);
        m.insert(Opcode::CLD, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x58];
        hm.insert(AddressMode::Implied, v);
        m.insert(Opcode::CLI, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0xB8];
        hm.insert(AddressMode::Implied, v);
        m.insert(Opcode::CLV, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0xCD];
        hm.insert(AddressMode::Absolute, v);
        let v: Vec<u8> = vec![0xDD];
        hm.insert(AddressMode::AbsoluteX, v);
        let v: Vec<u8> = vec![0xD9];
        hm.insert(AddressMode::AbsoluteY, v);
        let v: Vec<u8> = vec![0xC9];
        hm.insert(AddressMode::Immediate, v);
        let v: Vec<u8> = vec![0xC1];
        hm.insert(AddressMode::IndirectX, v);
        let v: Vec<u8> = vec![0xD1];
        hm.insert(AddressMode::IndirectY, v);
        let v: Vec<u8> = vec![0xC5];
        hm.insert(AddressMode::ZeroPage, v);
        let v: Vec<u8> = vec![0xD5];
        hm.insert(AddressMode::ZeroPageX, v);
        m.insert(Opcode::CMP, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0xEC];
        hm.insert(AddressMode::Absolute, v);
        let v: Vec<u8> = vec![0xE0];
        hm.insert(AddressMode::Immediate, v);
        let v: Vec<u8> = vec![0xE4];
        hm.insert(AddressMode::ZeroPage, v);
        m.insert(Opcode::CPX, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0xCC];
        hm.insert(AddressMode::Absolute, v);
        let v: Vec<u8> = vec![0xC0];
        hm.insert(AddressMode::Immediate, v);
        let v: Vec<u8> = vec![0xC4];
        hm.insert(AddressMode::ZeroPage, v);
        m.insert(Opcode::CPY, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0xCF];
        hm.insert(AddressMode::Absolute, v);
        let v: Vec<u8> = vec![0xDF];
        hm.insert(AddressMode::AbsoluteX, v);
        let v: Vec<u8> = vec![0xDB];
        hm.insert(AddressMode::AbsoluteY, v);
        let v: Vec<u8> = vec![0xC3];
        hm.insert(AddressMode::IndirectX, v);
        let v: Vec<u8> = vec![0xD3];
        hm.insert(AddressMode::IndirectY, v);
        let v: Vec<u8> = vec![0xC7];
        hm.insert(AddressMode::ZeroPage, v);
        let v: Vec<u8> = vec![0xD7];
        hm.insert(AddressMode::ZeroPageX, v);
        m.insert(Opcode::DCP, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0xCE];
        hm.insert(AddressMode::Absolute, v);
        let v: Vec<u8> = vec![0xDE];
        hm.insert(AddressMode::AbsoluteX, v);
        let v: Vec<u8> = vec![0xC6];
        hm.insert(AddressMode::ZeroPage, v);
        let v: Vec<u8> = vec![0xD6];
        hm.insert(AddressMode::ZeroPageX, v);
        m.insert(Opcode::DEC, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0xCA];
        hm.insert(AddressMode::Implied, v);
        m.insert(Opcode::DEX, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x88];
        hm.insert(AddressMode::Implied, v);
        m.insert(Opcode::DEY, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x4D];
        hm.insert(AddressMode::Absolute, v);
        let v: Vec<u8> = vec![0x5D];
        hm.insert(AddressMode::AbsoluteX, v);
        let v: Vec<u8> = vec![0x59];
        hm.insert(AddressMode::AbsoluteY, v);
        let v: Vec<u8> = vec![0x49];
        hm.insert(AddressMode::Immediate, v);
        let v: Vec<u8> = vec![0x41];
        hm.insert(AddressMode::IndirectX, v);
        let v: Vec<u8> = vec![0x51];
        hm.insert(AddressMode::IndirectY, v);
        let v: Vec<u8> = vec![0x45];
        hm.insert(AddressMode::ZeroPage, v);
        let v: Vec<u8> = vec![0x55];
        hm.insert(AddressMode::ZeroPageX, v);
        m.insert(Opcode::EOR, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x02, 0x12, 0x22, 0x32, 0x42, 0x52, 0x62, 0x72, 0x92, 0xB2, 0xD2, 0xF2];
        hm.insert(AddressMode::Implied, v);
        m.insert(Opcode::HLT, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0xEE];
        hm.insert(AddressMode::Absolute, v);
        let v: Vec<u8> = vec![0xFE];
        hm.insert(AddressMode::AbsoluteX, v);
        let v: Vec<u8> = vec![0xE6];
        hm.insert(AddressMode::ZeroPage, v);
        let v: Vec<u8> = vec![0xF6];
        hm.insert(AddressMode::ZeroPageX, v);
        m.insert(Opcode::INC, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0xE8];
        hm.insert(AddressMode::Implied, v);
        m.insert(Opcode::INX, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0xC8];
        hm.insert(AddressMode::Implied, v);
        m.insert(Opcode::INY, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0xEF];
        hm.insert(AddressMode::Absolute, v);
        let v: Vec<u8> = vec![0xFF];
        hm.insert(AddressMode::AbsoluteX, v);
        let v: Vec<u8> = vec![0xFB];
        hm.insert(AddressMode::AbsoluteY, v);
        let v: Vec<u8> = vec![0xE3];
        hm.insert(AddressMode::IndirectX, v);
        let v: Vec<u8> = vec![0xF3];
        hm.insert(AddressMode::IndirectY, v);
        let v: Vec<u8> = vec![0xE7];
        hm.insert(AddressMode::ZeroPage, v);
        let v: Vec<u8> = vec![0xF7];
        hm.insert(AddressMode::ZeroPageX, v);
        m.insert(Opcode::ISC, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x4C];
        hm.insert(AddressMode::Absolute, v);
        let v: Vec<u8> = vec![0x6C];
        hm.insert(AddressMode::Indirect, v);
        m.insert(Opcode::JMP, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x20];
        hm.insert(AddressMode::Absolute, v);
        m.insert(Opcode::JSR, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0xBB];
        hm.insert(AddressMode::AbsoluteY, v);
        m.insert(Opcode::LAS, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0xAF];
        hm.insert(AddressMode::Absolute, v);
        let v: Vec<u8> = vec![0xBF];
        hm.insert(AddressMode::AbsoluteY, v);
        let v: Vec<u8> = vec![0xA3];
        hm.insert(AddressMode::IndirectX, v);
        let v: Vec<u8> = vec![0xB3];
        hm.insert(AddressMode::IndirectY, v);
        let v: Vec<u8> = vec![0xA7];
        hm.insert(AddressMode::ZeroPage, v);
        let v: Vec<u8> = vec![0xB7];
        hm.insert(AddressMode::ZeroPageY, v);
        m.insert(Opcode::LAX, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0xAD];
        hm.insert(AddressMode::Absolute, v);
        let v: Vec<u8> = vec![0xBD];
        hm.insert(AddressMode::AbsoluteX, v);
        let v: Vec<u8> = vec![0xB9];
        hm.insert(AddressMode::AbsoluteY, v);
        let v: Vec<u8> = vec![0xA9];
        hm.insert(AddressMode::Immediate, v);
        let v: Vec<u8> = vec![0xA1];
        hm.insert(AddressMode::IndirectX, v);
        let v: Vec<u8> = vec![0xB1];
        hm.insert(AddressMode::IndirectY, v);
        let v: Vec<u8> = vec![0xA5];
        hm.insert(AddressMode::ZeroPage, v);
        let v: Vec<u8> = vec![0xB5];
        hm.insert(AddressMode::ZeroPageX, v);
        m.insert(Opcode::LDA, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0xAE];
        hm.insert(AddressMode::Absolute, v);
        let v: Vec<u8> = vec![0xBE];
        hm.insert(AddressMode::AbsoluteY, v);
        let v: Vec<u8> = vec![0xA2];
        hm.insert(AddressMode::Immediate, v);
        let v: Vec<u8> = vec![0xA6];
        hm.insert(AddressMode::ZeroPage, v);
        let v: Vec<u8> = vec![0xB6];
        hm.insert(AddressMode::ZeroPageY, v);
        m.insert(Opcode::LDX, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0xAC];
        hm.insert(AddressMode::Absolute, v);
        let v: Vec<u8> = vec![0xBC];
        hm.insert(AddressMode::AbsoluteX, v);
        let v: Vec<u8> = vec![0xA0];
        hm.insert(AddressMode::Immediate, v);
        let v: Vec<u8> = vec![0xA4];
        hm.insert(AddressMode::ZeroPage, v);
        let v: Vec<u8> = vec![0xB4];
        hm.insert(AddressMode::ZeroPageX, v);
        m.insert(Opcode::LDY, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x4E];
        hm.insert(AddressMode::Absolute, v);
        let v: Vec<u8> = vec![0x5E];
        hm.insert(AddressMode::AbsoluteX, v);
        let v: Vec<u8> = vec![0x4A];
        hm.insert(AddressMode::Implied, v);
        let v: Vec<u8> = vec![0x46];
        hm.insert(AddressMode::ZeroPage, v);
        let v: Vec<u8> = vec![0x56];
        hm.insert(AddressMode::ZeroPageX, v);
        m.insert(Opcode::LSR, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x0C];
        hm.insert(AddressMode::Absolute, v);
        let v: Vec<u8> = vec![0x1C, 0x3C, 0x5C, 0x7C, 0xDC, 0xFC];
        hm.insert(AddressMode::AbsoluteX, v);
        let v: Vec<u8> = vec![0x80, 0x82, 0x89, 0xC2, 0xE2];
        hm.insert(AddressMode::Immediate, v);
        let v: Vec<u8> = vec![0x1A, 0x3A, 0x5A, 0x7A, 0xDA, 0xEA, 0xFA];
        hm.insert(AddressMode::Implied, v);
        let v: Vec<u8> = vec![0x04, 0x44, 0x64];
        hm.insert(AddressMode::ZeroPage, v);
        let v: Vec<u8> = vec![0x14, 0x34, 0x54, 0x74, 0xD4, 0xF4];
        hm.insert(AddressMode::ZeroPageX, v);
        m.insert(Opcode::NOP, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0xAB];
        hm.insert(AddressMode::Immediate, v);
        m.insert(Opcode::OAL, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x0D];
        hm.insert(AddressMode::Absolute, v);
        let v: Vec<u8> = vec![0x1D];
        hm.insert(AddressMode::AbsoluteX, v);
        let v: Vec<u8> = vec![0x19];
        hm.insert(AddressMode::AbsoluteY, v);
        let v: Vec<u8> = vec![0x09];
        hm.insert(AddressMode::Immediate, v);
        let v: Vec<u8> = vec![0x01];
        hm.insert(AddressMode::IndirectX, v);
        let v: Vec<u8> = vec![0x11];
        hm.insert(AddressMode::IndirectY, v);
        let v: Vec<u8> = vec![0x05];
        hm.insert(AddressMode::ZeroPage, v);
        let v: Vec<u8> = vec![0x15];
        hm.insert(AddressMode::ZeroPageX, v);
        m.insert(Opcode::ORA, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x48];
        hm.insert(AddressMode::Implied, v);
        m.insert(Opcode::PHA, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x08];
        hm.insert(AddressMode::Implied, v);
        m.insert(Opcode::PHP, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x68];
        hm.insert(AddressMode::Implied, v);
        m.insert(Opcode::PLA, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x28];
        hm.insert(AddressMode::Implied, v);
        m.insert(Opcode::PLP, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x2F];
        hm.insert(AddressMode::Absolute, v);
        let v: Vec<u8> = vec![0x3F];
        hm.insert(AddressMode::AbsoluteX, v);
        let v: Vec<u8> = vec![0x3B];
        hm.insert(AddressMode::AbsoluteY, v);
        let v: Vec<u8> = vec![0x23];
        hm.insert(AddressMode::IndirectX, v);
        let v: Vec<u8> = vec![0x33];
        hm.insert(AddressMode::IndirectY, v);
        let v: Vec<u8> = vec![0x27];
        hm.insert(AddressMode::ZeroPage, v);
        let v: Vec<u8> = vec![0x37];
        hm.insert(AddressMode::ZeroPageX, v);
        m.insert(Opcode::RLA, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x2E];
        hm.insert(AddressMode::Absolute, v);
        let v: Vec<u8> = vec![0x3E];
        hm.insert(AddressMode::AbsoluteX, v);
        let v: Vec<u8> = vec![0x2A];
        hm.insert(AddressMode::Implied, v);
        let v: Vec<u8> = vec![0x26];
        hm.insert(AddressMode::ZeroPage, v);
        let v: Vec<u8> = vec![0x36];
        hm.insert(AddressMode::ZeroPageX, v);
        m.insert(Opcode::ROL, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x6E];
        hm.insert(AddressMode::Absolute, v);
        let v: Vec<u8> = vec![0x7E];
        hm.insert(AddressMode::AbsoluteX, v);
        let v: Vec<u8> = vec![0x6A];
        hm.insert(AddressMode::Implied, v);
        let v: Vec<u8> = vec![0x66];
        hm.insert(AddressMode::ZeroPage, v);
        let v: Vec<u8> = vec![0x76];
        hm.insert(AddressMode::ZeroPageX, v);
        m.insert(Opcode::ROR, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x6F];
        hm.insert(AddressMode::Absolute, v);
        let v: Vec<u8> = vec![0x7F];
        hm.insert(AddressMode::AbsoluteX, v);
        let v: Vec<u8> = vec![0x7B];
        hm.insert(AddressMode::AbsoluteY, v);
        let v: Vec<u8> = vec![0x63];
        hm.insert(AddressMode::IndirectX, v);
        let v: Vec<u8> = vec![0x73];
        hm.insert(AddressMode::IndirectY, v);
        let v: Vec<u8> = vec![0x67];
        hm.insert(AddressMode::ZeroPage, v);
        let v: Vec<u8> = vec![0x77];
        hm.insert(AddressMode::ZeroPageX, v);
        m.insert(Opcode::RRA, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x40];
        hm.insert(AddressMode::Implied, v);
        m.insert(Opcode::RTI, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x60];
        hm.insert(AddressMode::Implied, v);
        m.insert(Opcode::RTS, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x8F];
        hm.insert(AddressMode::Absolute, v);
        let v: Vec<u8> = vec![0x83];
        hm.insert(AddressMode::IndirectX, v);
        let v: Vec<u8> = vec![0x87];
        hm.insert(AddressMode::ZeroPage, v);
        let v: Vec<u8> = vec![0x97];
        hm.insert(AddressMode::ZeroPageY, v);
        m.insert(Opcode::SAX, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0xED];
        hm.insert(AddressMode::Absolute, v);
        let v: Vec<u8> = vec![0xFD];
        hm.insert(AddressMode::AbsoluteX, v);
        let v: Vec<u8> = vec![0xF9];
        hm.insert(AddressMode::AbsoluteY, v);
        let v: Vec<u8> = vec![0xE9, 0xEB];
        hm.insert(AddressMode::Immediate, v);
        let v: Vec<u8> = vec![0xE1];
        hm.insert(AddressMode::IndirectX, v);
        let v: Vec<u8> = vec![0xF1];
        hm.insert(AddressMode::IndirectY, v);
        let v: Vec<u8> = vec![0xE5];
        hm.insert(AddressMode::ZeroPage, v);
        let v: Vec<u8> = vec![0xF5];
        hm.insert(AddressMode::ZeroPageX, v);
        m.insert(Opcode::SBC, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x38];
        hm.insert(AddressMode::Implied, v);
        m.insert(Opcode::SEC, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0xF8];
        hm.insert(AddressMode::Implied, v);
        m.insert(Opcode::SED, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x78];
        hm.insert(AddressMode::Implied, v);
        m.insert(Opcode::SEI, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x9E];
        hm.insert(AddressMode::AbsoluteY, v);
        m.insert(Opcode::SHX, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x9C];
        hm.insert(AddressMode::AbsoluteX, v);
        m.insert(Opcode::SHY, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x0F];
        hm.insert(AddressMode::Absolute, v);
        let v: Vec<u8> = vec![0x1F];
        hm.insert(AddressMode::AbsoluteX, v);
        let v: Vec<u8> = vec![0x1B];
        hm.insert(AddressMode::AbsoluteY, v);
        let v: Vec<u8> = vec![0x03];
        hm.insert(AddressMode::IndirectX, v);
        let v: Vec<u8> = vec![0x13];
        hm.insert(AddressMode::IndirectY, v);
        let v: Vec<u8> = vec![0x07];
        hm.insert(AddressMode::ZeroPage, v);
        let v: Vec<u8> = vec![0x17];
        hm.insert(AddressMode::ZeroPageX, v);
        m.insert(Opcode::SLO, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x4F];
        hm.insert(AddressMode::Absolute, v);
        let v: Vec<u8> = vec![0x5F];
        hm.insert(AddressMode::AbsoluteX, v);
        let v: Vec<u8> = vec![0x5B];
        hm.insert(AddressMode::AbsoluteY, v);
        let v: Vec<u8> = vec![0x43];
        hm.insert(AddressMode::IndirectX, v);
        let v: Vec<u8> = vec![0x53];
        hm.insert(AddressMode::IndirectY, v);
        let v: Vec<u8> = vec![0x47];
        hm.insert(AddressMode::ZeroPage, v);
        let v: Vec<u8> = vec![0x57];
        hm.insert(AddressMode::ZeroPageX, v);
        m.insert(Opcode::SRE, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x8D];
        hm.insert(AddressMode::Absolute, v);
        let v: Vec<u8> = vec![0x9D];
        hm.insert(AddressMode::AbsoluteX, v);
        let v: Vec<u8> = vec![0x99];
        hm.insert(AddressMode::AbsoluteY, v);
        let v: Vec<u8> = vec![0x81];
        hm.insert(AddressMode::IndirectX, v);
        let v: Vec<u8> = vec![0x91];
        hm.insert(AddressMode::IndirectY, v);
        let v: Vec<u8> = vec![0x85];
        hm.insert(AddressMode::ZeroPage, v);
        let v: Vec<u8> = vec![0x95];
        hm.insert(AddressMode::ZeroPageX, v);
        m.insert(Opcode::STA, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x8E];
        hm.insert(AddressMode::Absolute, v);
        let v: Vec<u8> = vec![0x86];
        hm.insert(AddressMode::ZeroPage, v);
        let v: Vec<u8> = vec![0x96];
        hm.insert(AddressMode::ZeroPageY, v);
        m.insert(Opcode::STX, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x8C];
        hm.insert(AddressMode::Absolute, v);
        let v: Vec<u8> = vec![0x84];
        hm.insert(AddressMode::ZeroPage, v);
        let v: Vec<u8> = vec![0x94];
        hm.insert(AddressMode::ZeroPageX, v);
        m.insert(Opcode::STY, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x9B];
        hm.insert(AddressMode::AbsoluteY, v);
        m.insert(Opcode::TAS, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0xAA];
        hm.insert(AddressMode::Implied, v);
        m.insert(Opcode::TAX, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0xA8];
        hm.insert(AddressMode::Implied, v);
        m.insert(Opcode::TAY, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0xBA];
        hm.insert(AddressMode::Implied, v);
        m.insert(Opcode::TSX, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x8A];
        hm.insert(AddressMode::Implied, v);
        m.insert(Opcode::TXA, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x9A];
        hm.insert(AddressMode::Implied, v);
        m.insert(Opcode::TXS, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x98];
        hm.insert(AddressMode::Implied, v);
        m.insert(Opcode::TYA, hm);
        let mut hm = HashMap::new();
        let v: Vec<u8> = vec![0x8B];
        hm.insert(AddressMode::Immediate, v);
        m.insert(Opcode::XAA, hm);

        for op in Opcode::iter() {
            match m.get(&op) {
                Some(_) => {},
                None => panic!("Not all opcodes covered!. Missing {op}"),
            };
        }

        m
    };

    // OPCODES_VALUES is the inverse of OPCODES where the keys are the u8 byte codes and values Operation defining
    // the Opcode and AddressMode. Used in processing the CPU tick() or in disassembly for mapping a byte code back
    // to an Opcode.
    static ref OPCODES_VALUES: Vec<Operation> = {
        // We know this much be a vector of all u8 values since the 6502
        // has behavior at each so we'll have some combo of opcode/addressmode.
        //
        // Preallocate a vector of that size and fill with placeholders.
        // Then track in the hashset which indexes we've seen (panic on dups)
        // and insert directly to each index.
        let mut m = Vec::new();
        m.resize(1 << 8, Operation{
            op: Opcode::BRK,
            mode: AddressMode::Implied,
        });
        let sl = m.as_mut_slice();
        let mut hs = HashSet::new();

        for (op, hm) in OPCODES.iter() {
            for (am, opbytes) in hm {
                for opbyte in opbytes {
                    assert!(!hs.contains(opbyte),"OPCODES contains multiple entries for {opbyte:#04X} found in opcode {op} but we already have {:?}", sl[usize::from(*opbyte)]);
                    hs.insert(*opbyte);
                    sl[usize::from(*opbyte)] = Operation{
                                op: *op,
                                mode: *am,
                    };
                }
            }
        }

        assert!(hs.len() == (1 << 8), "Didn't fill out {} opcodes. Only defined {} - {:?}", 1<<8, hs.len(), m);
        m
    };
}

/// Given an `Opcode` and `AddressMode` return the valid u8 values that
/// can represent it.
///
/// # Errors
/// If the `AddressMode` is not valid for this opcode an error will result.
pub fn resolve_opcode(op: &Opcode, mode: &AddressMode) -> Result<&'static Vec<u8>> {
    let hm: &HashMap<AddressMode, Vec<u8>>;
    // Safety: When we built OPCODES we validated all Opcode were present
    unsafe {
        hm = OPCODES.get(op).unwrap_unchecked();
    }
    if let Some(v) = hm.get(mode) {
        Ok(v)
    } else {
        Err(eyre!("address mode {mode} isn't valid for opcode {op}"))
    }
}

/// Given an opcode u8 value this will return the Operation struct
/// defining it. i.e. `Opcode` and `AddressMode`.
#[must_use]
pub fn opcode_op(op: u8) -> Operation {
    // Safety: We know a u8 is in range due to how we build this
    //         so a direct index is fine.
    OPCODES_VALUES[usize::from(op)]
}
